export PATH=/usr/local/bin:${PATH}
fpath=($HOME/.zsh/func $fpath)
typeset -U fpath

# Vim keybindings
set -o vi
bindkey -v
bindkey "^?" backward-delete-char
bindkey "^W" backward-kill-word
bindkey "^H" backward-delete-char
bindkey "^U" kill-line
bindkey "^R" history-incremental-search-backward

autoload -U compinit
compinit

autoload -U colors
colors

setopt interactivecomments
setopt rmstarsilent
setopt prompt_subst
setopt append_history

# Only unique history entries in the reverse history search HIST_FIND_NO_DUPS=1
setopt hist_ignore_all_dups
setopt hist_ignore_dups


# Ignore duplicate history entries
zstyle ':completion:*:history-words' stop yes
zstyle ':completion:*:history-words' remove-all-dups yes
zstyle ':completion:*:history-words' list false
zstyle ':completion:*:history-words' menu yes


HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

# Function to attach to a session. If the session is not specified then
#just run `tmux attach`, otherwise add a -t flag
function _tmux_attach() {
    if [ $1 ]; then
        tmux attach -t $1
    else
        tmux attach
    fi
}

function gi() {
    # This function gets the gitignore results from gitignore.io and prints them
    # to screen
    #
    # Inputs: any extra arguments given on the command line are treated as
    # ignore classes for the website.
    #
    # E.g. > gi linux osx python
    #
    # will translate to http://gitignore.io/api/linux,osx,python
    URL=http://gitignore.io/api/
    ARGS=$(echo $* | sed 's/ /,/g')
    curl ${URL}${ARGS}
}


# From GRB
function mcd() { mkdir -p $1 && cd $1 }
function cdf() { cd *$1*/ }

local fifo_name='.fifo'
function ensure_fifo() {
    if [ ! -p $fifo_name ]; then
        mkfifo $fifo_name
    fi
}

function listen() {
    echo "Listening for commands"
    ensure_fifo && while true; do sh -c "$(cat $fifo_name)"; done
}


# Alias some tmux commands
alias ta=_tmux_attach
alias tns="tmux new-session -s"
alias tls="tmux ls"

export PATH=${HOME}/.bin:${HOME}/prefix/bin:$PATH
export EDITOR=vim_nox
export VISUAL=${EDITOR}
export BIBINPUTS=${HOME}/work/central-bibliography:${BIBINPUTS}
export TERM=screen-256color

# Taken from grb's zshrc

# By default, zsh considers many characters part of a word (e.g., _ and -).
# Narrow that down to allow easier skipping through words via M-f and M-b.
export WORDCHARS='*?[]~&;!$%^<>'

alias pylab="ipython --pylab"
alias py='ipython --pylab'
alias pydoc='python -m pydoc'
alias vim=vim_nox
alias ls='ls -F'

# Git aliases
alias g=git

# Update vim plugins
alias vbi='vim +BundleInstall +qa'
alias vbu='vim +BundleUpdate'

# Ruby aliases
alias bcb='bundle check; bundle install --binstubs .bundle/bin'

case $OSTYPE in
    linux*)
        export LD_LIBRARY_PATH=${HOME}/prefix/lib:${LD_LIBRARY_PATH}

        # Set up the module command
        function module() { eval `modulecmd zsh $*`; }

        # If the server is at Leicester, source the intel compiler variables
        if [[ `dnsdomainname` == "star.le.ac.uk" ]]; then
            source /opt/intel/composerxe-2011.0.084/bin/compilervars.sh intel64 2>/dev/null
            source /usr/local/sge/default/common/settings.sh
        fi

        VIRTUALENV_DIR=${HOME}/PythonEnv
        VIRTUALENV_SOURCE_FILE=${VIRTUALENV_DIR}/bin/activate
        if [[ -f ${VIRTUALENV_SOURCE_FILE} ]]; then
            # Set up the python environment
            # Set the environment variable for only this env to disable the prompt
            VIRTUAL_ENV_DISABLE_PROMPT=1 source ${VIRTUALENV_SOURCE_FILE}
            # export PYTHONPATH=${VIRTUALENV_DIR}/lib/python2.7/site-packages:$PYTHONPATH
        fi

        # Set up chruby
        source ${HOME}/prefix/share/chruby/chruby.sh
        RUBIES=(~/.rbenv/versions/*)
        ;;
    darwin*)
        export PATH=${PATH}:/usr/texbin:/usr/local/share/npm/bin:/usr/local/sbin
        alias gvim=mvim
        alias gview=mview
        alias -g awk=gawk

        # Set up chruby
        source /usr/local/opt/chruby/share/chruby/chruby.sh
        RUBIES=(/usr/local/var/rbenv/versions/*)
        ;;
esac

chruby 2.0.0

# Prompt customising
function parse_git_dirty() {
  local SUBMODULE_SYNTAX=''
  local GIT_STATUS=''
  local CLEAN_MESSAGE='nothing to commit (working directory clean)'
  if [[ "$(command git config --get oh-my-zsh.hide-status)" != "1" ]]; then
    if [[ $POST_1_7_2_GIT -gt 0 ]]; then
          SUBMODULE_SYNTAX="--ignore-submodules=dirty"
    fi
    if [[ "$DISABLE_UNTRACKED_FILES_DIRTY" == "true" ]]; then
        GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} -uno 2> /dev/null | tail -n1)
    else
        GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} 2> /dev/null | tail -n1)
    fi
    if [[ -n $GIT_STATUS ]]; then
      echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
    else
      echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
    fi
  else
    echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
  fi
}

# get the name of the branch we are on
function git_prompt_info() {
  ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
  ref=$(command git rev-parse --short HEAD 2> /dev/null) || return
  echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
}

local green="%{$fg_bold[green]%}"
local yellow="%{$fg_bold[yellow]%}"
local red="%{$fg_bold[red]%}"
local reset="%{$reset_color%}"

ZSH_THEME_GIT_PROMPT_PREFIX='('
ZSH_THEME_GIT_PROMPT_SUFFIX=')'
ZSH_THEME_GIT_PROMPT_DIRTY="|${red}✗${reset}"
ZSH_THEME_GIT_PROMPT_CLEAN=''
PROMPT="%(?.$green.$red)>$reset "
RPROMPT='%1~$green$(git_prompt_info)$reset@$yellow$(hostname)$reset'

# Source the custom zshrc.local file in the system
if [[ -f ${HOME}/.zshrc.local ]]; then
    source ${HOME}/.zshrc.local
fi

