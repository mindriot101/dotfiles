#!/usr/bin/env python


import shlex
import sys
import argparse
import subprocess as sp
import logging


class Git:
    @classmethod
    def merge_base(cls, upstream, current):
        return cls._get_command_output(["git", "merge-base", upstream, current])

    @classmethod
    def rev_parse(cls, name, abbrev_ref=False):
        cmd = ["git", "rev-parse"]
        if abbrev_ref:
            cmd.append("--abbrev-ref")
        cmd.append(name)

        return cls._get_command_output(cmd)

    @classmethod
    def rev_list(cls, start, end, reverse=False):
        cmd = ["git", "rev-list", f"{start}..{end}"]
        if reverse:
            cmd.append("--reverse")

        output = cls._get_command_output(cmd)
        return output.split("\n")

    @classmethod
    def checkout(cls, rev):
        cls._run_command(["git", "checkout", "--quiet", rev])

    @classmethod
    def reset(cls, hard=False):
        cls._run_command(["git", "reset", "--hard"])

    @staticmethod
    def _get_command_output(cmd):
        return sp.check_output(cmd).decode().strip()

    @staticmethod
    def _run_command(cmd):
        sp.check_call(cmd)


def run_command(cmd):
    return Git._run_command(cmd)


def main():
    if len(sys.argv) == 1:
        command = ["pytest", "-n", "auto", "-x"]
    else:
        command = sys.argv[1:]

    start = Git.merge_base("master", "HEAD")
    end = Git.rev_parse("HEAD")
    symbolic_end = Git.rev_parse("HEAD", abbrev_ref=True)

    try:
        revisions = Git.rev_list(start, end, reverse=True)
        if end not in revisions:
            revisions.append(end)

        for revision in revisions:
            Git.checkout(revision)
            run_command(command)
    except Exception as e:
        Git.checkout(symbolic_end)
        Git.reset(hard=True)
        print(f"Command failed: {e}", file=sys.stderr)
        sys.exit(1)

    print("OK")


if __name__ == "__main__":
    main()
