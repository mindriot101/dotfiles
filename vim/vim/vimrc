let g:mapleader = ","
let g:maplocalleader = '\\'

" remove all existing autocmds
autocmd!

call plug#begin('~/.vim/bundle')

if !has('nvim')
    Plug 'tpope/vim-sensible'
endif

syntax on

Plug 'junegunn/fzf.vim'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install --no-update-rc --no-completion --key-bindings' }
Plug 'tpope/vim-surround'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-obsession'
Plug 'christoomey/vim-tmux-runner'
Plug 'christoomey/vim-conflicted'
Plug 'vim-test/vim-test'
Plug 'junegunn/vim-easy-align'
Plug 'junegunn/goyo.vim'
Plug 'neoclide/coc.nvim', { 'branch': 'release' }
Plug 'chriskempson/base16-vim'
Plug 'shumphrey/fugitive-gitlab.vim'
Plug 'heavenshell/vim-pydocstring'
Plug 'NLKNguyen/papercolor-theme'
Plug 'itchyny/lightline.vim'
Plug 'rodrigore/coc-tailwind-intellisense', {'do': 'npm install'}
Plug 'direnv/direnv.vim'

" My plugins
Plug 'https://gitlab.com/srwalker101/pytest-callgraph.git'

" language plugins
Plug 'cespare/vim-toml'
Plug 'jeetsukumaran/vim-pythonsense'
Plug 'fatih/vim-go'
Plug 'rust-lang/rust.vim'
Plug 'evanleck/vim-svelte'
Plug 'ElmCast/elm-vim'
Plug 'leafgarland/typescript-vim'
Plug 'hashivim/vim-terraform'

if has('nvim-0.5')
    augroup LuaHighlight
        autocmd!
        autocmd TextYankPost * silent! lua require'vim.highlight'.on_yank()
    augroup END
else
    Plug 'machakann/vim-highlightedyank'
endif

call plug#end()

set mouse=a
set scrolloff=5
set nonumber
set norelativenumber
set nocursorline
set ttimeoutlen=10
set shiftwidth=4
set tabstop=4
set smartcase
set expandtab
set ignorecase
set hidden
set tags+=.git/tags
set wildmode=list:longest,list:full
set history=50
set complete=.,w,b,u,t,i
set ruler
set nolist
set showcmd
set incsearch
set nohlsearch
set laststatus=2
set backspace=2
set autowrite
set nowrap
set textwidth=0
set breakindent
set synmaxcol=1024
if has('nvim')
    set termguicolors
    set inccommand=nosplit
else
    set ttyfast
endif
set linebreak
" Use global regex replaces by default
set gdefault
" Configure minimum window width
set winwidth=80
" speed up UI updates
set updatetime=100
" If buffer is already open when switching, switch to it
set switchbuf+=useopen
" configure concealing things
set conceallevel=0
" configure shortmessages
set shortmess=tToOFIWa
" Do not hide sign column
set signcolumn=auto

" Center search results
nnoremap <silent> n nzz
nnoremap <silent> N Nzz
nnoremap <silent> * *zz
nnoremap <silent> # #zz
nnoremap <silent> g* g*zz

" Very magic search always
nnoremap / /\v
nnoremap ? ?\v

" Sane splits
set splitright
set splitbelow

" --- Set up backups
" Protect changes between writes. Default values of
" updatecount (200 keystrokes) and updatetime
" (4 seconds) are fine
set swapfile
set directory^=~/.vim/swap//

" protect against crash-during-write
set writebackup
" but do not persist backup after successful write
set nobackup
" use rename-and-write-new method whenever safe
set backupcopy=auto
" patch required to honor double slash at end
if has("patch-8.1.0251")
    " consolidate the writebackups -- not a big
    " deal either way, since they usually get deleted
    set backupdir^=~/.vim/backup//
end

" Set up persistent undo
set undofile
set undodir=~/.vimundo

set modeline
set lazyredraw

nnoremap <C-h> <C-w><C-h>
nnoremap <C-j> <C-w><C-j>
nnoremap <C-k> <C-w><C-k>
nnoremap <C-l> <C-w><C-l>
nnoremap cp :0,$y+<Cr>
nnoremap ' `
nnoremap ` '
nnoremap j gj
nnoremap k gk

cnoremap %s/ %sm/

" escape with Ctrl-j
inoremap <C-j> <esc>
vnoremap <C-j> <esc>
inoremap <C-c> <esc>
vnoremap <C-c> <esc>

" Reselect visual block after indent/outdent
vnoremap < <gv
vnoremap > >gv

if executable('rg')
    let &grepprg="rg --vimgrep"
endif

" FZF
set rtp+=~/.fzf
let g:fzf_command_prefix = 'Fzf'
nnoremap <leader>f :FzfGitFiles<cr>
nnoremap <leader>F :FzfFiles<cr>
nnoremap gb :FzfBuffers<cr>
nnoremap gl :FzfRg<cr>
nnoremap gL :FzfBLines<cr>
nnoremap <leader>gT :FzfTags<cr>
nnoremap <leader>gt :FzfBTags<cr>
nnoremap <leader>a :FzfRg<cr>

" Configure fzf window style
let g:fzf_layout = { 'window': { 'width': 1, 'height': 0.4, 'yoffset': 1, 'border': 'top' } }

" Configure vim tmux runner
let g:VtrStripLeadingWhitespace = 0
let g:VtrClearEmptyLines = 1
let g:VtrAppendNewline = 1

" Expand %% to the current directory
cnoremap %% <c-r>=expand('%:h') . '/'<cr>

nnoremap <silent> <leader>vr :source $MYVIMRC\|echo "Reloaded!"<Cr>
nnoremap <silent> <leader>ev :echo "Use <leader>ve"<Cr>

" Add mapping to open/close the quickfix list
" Taken from: http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

" nmap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>
nmap <silent> Q :call ToggleList("Quickfix List", 'c')<CR>

" Bind K to grep word under cursor
nnoremap <silent> K :grep! "<C-R><C-W>"<cr><cr>\|:copen<Cr>

" Switch panes
nnoremap <leader><leader> <C-^>

" remove help key
map <F1> <Esc>
imap <F1> <Esc>

" Configure vim test
nnoremap <silent> tf :update\|:TestFile<Cr>
nnoremap <silent> tl :update\|:TestLast<Cr>
nnoremap <silent> tn :update\|:TestNearest<Cr>
nnoremap <silent> ta :update\|:TestSuite<Cr>
nnoremap <silent> ts :update\|:TestSuite<Cr>
let test#python#runner = 'pytest'
let test#javascript#reactscripts#options = "--watchAll=false"

nnoremap <leader>v :VtrAttachToPane<cr>

" Create shorter 'V' command which is easier to type
command! -nargs=? V call VtrSendCommand(<f-args>)

" Configure vim fugitive
nnoremap <leader>gc :Git commit -v<cr>
nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>gr :Gread<cr>
nnoremap gs :Git<cr>
nnoremap <leader>ga :Git commit -v --amend<cr>

" create a command to show my nice log
" nnoremap <leader>gL :Git log 
command! GitLog Git log --graph --decorate --pretty=format:'%C(auto)%h%C(reset) %C(green)(%ar)%C(reset) %C(blue)[%an]%C(auto) %d %s%C(auto)' --exclude='refs/bugs/*' --exclude='refs/identities/*'
nnoremap <leader>gL :GitLog<cr>

augroup last_position
    autocmd!
    " When editing a file, always jump to the last known cursor position.
    " Don't do it for commit messages, when the position is invalid, or when
    " inside an event handler (happens when dropping a file on gvim).
    autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
augroup END

" Configure neovim's terminal mode
if has('nvim')
    tnoremap <Esc> <C-\><C-n>
    tnoremap <M-[> <Esc>
    tnoremap <C-v><Esc> <Esc>

    augroup terminal_settings
        autocmd!
        autocmd TermOpen * startinsert
    augroup END
endif

" Automatically format elixir files on save
let g:mix_format_on_save = 1

" Configure rust format
let g:rustfmt_autosave = 1
let g:rustfmt_emit_files = 1
let g:rustfmt_fail_silently = 0

if has('nvim')
    runtime! plugin/python_setup.vim
endif

" Disable go version warnings
let g:go_version_warning = 0
let g:go_def_mode='gopls'
let g:go_info_mode='gopls'

" Configure elm.vim
let g:elm_format_fail_silently = 1

" configure conflicted status line
" set statusline=%<%f\ %{coc#status()}%{get(b:,'coc_current_function','')}%h%m%r%=%-14.(%l,%c%V%)\ %P
" set statusline+=%{ConflictedVersion()}

" Enable autoformatting of valid pretter-compatible files
let g:prettier#autoformat = 1
let g:prettier#autoformat_require_pragma = 0

" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" configure todo list management 
function! s:note(name)
    let l:notes_path = expand("$HOME") . "/notes/"
    let l:note_stub = substitute(a:name, " ", "-", "g")
    let l:note_name = l:notes_path . l:note_stub . ".md"
    execute 'split ' . l:note_name
endfunction

function! s:todo()
    let l:monday_date = trim(system("gdate -d monday +%Y-%m-%d"))
    echo l:monday_date
    call s:note('todo-' . l:monday_date)
endfunction

function! s:todo_last_week()
    let l:last_monday_date = trim(system("gdate -d last-monday +%Y-%m-%d"))
    echo l:last_monday_date
    call s:note('todo-' . l:last_monday_date)
endfunction

command! -nargs=0 Todo :call s:todo()
command! -nargs=0 TodoLastWeek :call s:todo_last_week()
command! -nargs=1 Note :call s:note(<f-args>)

nnoremap cd :Todo<cr>

" Triggering completion
inoremap <silent><expr> <c-p> coc#refresh()
inoremap <silent><expr> <c-n> coc#refresh()

nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)
nnoremap <silent> gh :CocList symbols<cr>
nnoremap <silent> <leader>cr :CocRestart<cr>

" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')
nnoremap <silent> <leader>y :Format<cr>

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)

" Use K to show documentation in preview window.
nnoremap <silent> <leader>d :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

let g:dispatch_quickfix_height=40
let g:dispatch_tmux_height=40

" configure custom rshtuff test runner
function! RShtuffStrategy(cmd)
    if !exists('g:rshtuff_listener')
        echoerr 'You must define g:rshtuff_listener to use this strategy'
        return
    endif

    call system("rshtuff -n " . shellescape(g:rshtuff_listener) . " send " . shellescape(a:cmd) . " --clear")
endfunction

function! SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

let g:rshtuff_listener = "testrunner"
let g:test#custom_strategies = {'rshtuff': function('RShtuffStrategy')}
let g:test#strategy = 'basic'

let g:coc_global_extensions = [ 'coc-pyright', 'coc-json', 'coc-go', 'coc-rust-analyzer', 'coc-git', 'coc-emoji']
let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_new_list_item_indent= 0
let g:vim_markdown_no_default_key_mappings = 1
let g:markdown_fenced_languages = ["python", "javascript", "toml", "rust"]

" prevent coc-emoji leaving behind the initial colon
" https://github.com/neoclide/coc-sources/issues/15#issuecomment-636398317
if exists('*complete_info')
  inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
endif


" configure python3 for neovim
"
" We ensure that a global python installation with the python3 file is set 
let s:python3_venv_path = expand("~/.local/share/nvim/venv3")
let s:python3_interp_path = s:python3_venv_path . "/bin/python"
if filereadable(s:python3_interp_path)
    let g:python3_host_prog = s:python3_interp_path
else
    echoerr "Python3 virtual environment not set up at " . s:python3_venv_path
        \ . ". Create virtual environment there and install `pynvim`."
endif

" mapping to set up run command
nnoremap <leader>V :nnoremap <silent> <leader>t :update\\|:V<space>
nnoremap <leader>T :nnoremap <silent> <leader>t :update\\|:T<space>

" configure abbreviations
source ~/.vim/abbreviations.vim

" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" navigate chunks of current buffer
nmap [c <Plug>(coc-git-prevchunk)
nmap ]c <Plug>(coc-git-nextchunk)
" show chunk diff at current position
nmap gp <Plug>(coc-git-chunkinfo)

" Show available actions
nnoremap <silent> <leader>ca :CocAction<cr>

augroup go_imports
    autocmd!
    autocmd BufWritePre *.go :call CocAction('organizeImport')
augroup END

let g:hardtime_default_on = 1
let g:hardtime_ignore_quickfix = 1
let g:hardtime_allow_different_key = 1
let g:hardtime_maxcount = 2

" Command to split a terminal window
command! -nargs=* -complete=shellcmd T split | resize 30 | term <args>

" configure fugitive-gitlab
let g:fugitive_gitlab_domains = ["https://gitlab.pixsystem.net", "https://gitlab.com"]

" configure nord
let g:nord_uniform_diff_background = 1

if has('nvim-0.4.0') || has('patch-8.2.0750')
    nnoremap <nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    nnoremap <nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
    inoremap <nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
    inoremap <nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
endif

inoremap <silent><expr> <TAB>
    \ pumvisible() ? "\<C-y>" : "\<TAB>"

function! s:check_back_space() abort
    let col = col(".") - 1
    return !col || getline(".")[col - 1] =~# '\s'
endfunction

" Disable concealing with indentline
let g:indentLine_setConceal = 0

" Support directory local vimrc files
" https://github.com/direnv/direnv/wiki/Vim
if exists("$EXTRA_VIM")
  for path in split($EXTRA_VIM, ':')
    exec "source ".path
  endfor
endif

" Lightline
let g:lightline = {}
let g:lightline.colorscheme = 'default'
let g:lightline.active = {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'cocstatus', 'readonly', 'filename', 'modified', 'gitstatus' ] ]
      \ }
let g:lightline.mode_map = {
        \ 'n' : 'N',
        \ 'i' : 'I',
        \ 'R' : 'R',
        \ 'v' : 'V',
        \ 'V' : 'VL',
        \ "\<C-v>": 'VB',
        \ 'c' : 'C',
        \ 's' : 'S',
        \ 'S' : 'SL',
        \ "\<C-s>": 'SB',
        \ 't': 'T',
        \ }
let g:lightline.inactive = g:lightline.active
let g:lightline.component_function = {
      \   'filename': 'LightlineFilename',
      \   'cocstatus': 'coc#status',
      \   'gitstatus': 'FugitiveStatusline'
      \ }
function! LightlineFilename()
  return expand('%:t') !=# '' ? @% : '[No Name]'
endfunction

let g:pydocstring_doq_path = expand("$HOME") . '/.local/pipx/bin/doq'
let g:pydocstring_formatter = "sphinx"
let g:pydocstring_enable_mapping = 0

set background=dark
colorscheme srw256
